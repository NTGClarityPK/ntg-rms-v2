-- Migration: Create Translation System Tables
-- This migration creates tables for AI-powered multi-language translations
-- Supports dynamic language management and extensible translation storage

-- ============================================
-- TRANSLATION SYSTEM TABLES
-- ============================================

-- Supported Languages Registry
-- Stores all languages that the system supports
CREATE TABLE IF NOT EXISTS supported_languages (
    code VARCHAR(10) PRIMARY KEY, -- ISO 639-1 code: 'en', 'ar', 'ku', 'fr'
    name VARCHAR(100) NOT NULL, -- Display name in English: 'English', 'Arabic', 'Kurdish', 'French'
    native_name VARCHAR(100) NOT NULL, -- Native name: 'English', 'العربية', 'کوردی', 'Français'
    is_active BOOLEAN DEFAULT true,
    is_default BOOLEAN DEFAULT false, -- Only one language can be default
    rtl BOOLEAN DEFAULT false, -- Right-to-left support for Arabic, Kurdish
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT supported_languages_code_check CHECK (char_length(code) >= 2 AND char_length(code) <= 10)
);

-- Translation Metadata
-- Links entities (ingredients, categories, food_items, etc.) to their translations
CREATE TABLE IF NOT EXISTS translation_metadata (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    entity_type VARCHAR(50) NOT NULL, -- 'ingredient', 'category', 'food_item', 'addon', 'variation', 'addon_group', 'variation_group'
    entity_id UUID NOT NULL,
    source_language VARCHAR(10) NOT NULL REFERENCES supported_languages(code), -- Original language of input
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(entity_type, entity_id),
    CONSTRAINT translation_metadata_entity_type_check CHECK (
        entity_type IN (
            'ingredient', 'category', 'food_item', 'addon', 
            'variation', 'addon_group', 'variation_group', 
            'buffet', 'combo_meal', 'menu', 'branch', 'customer',
            'employee', 'stock_operation', 'invoice', 'tax', 'restaurant'
        )
    )
);

-- Translations
-- Stores actual translated content for each field of each entity
CREATE TABLE IF NOT EXISTS translations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    metadata_id UUID NOT NULL REFERENCES translation_metadata(id) ON DELETE CASCADE,
    language_code VARCHAR(10) NOT NULL REFERENCES supported_languages(code),
    field_name VARCHAR(50) NOT NULL, -- 'name', 'description', 'title', etc.
    translated_text TEXT NOT NULL,
    is_ai_generated BOOLEAN DEFAULT true, -- true if generated by AI, false if manually edited
    last_updated_by UUID REFERENCES users(id) ON DELETE SET NULL, -- NULL if AI-generated, user_id if manually edited
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(metadata_id, language_code, field_name),
    CONSTRAINT translations_field_name_check CHECK (
        field_name IN (
            'name', 'description', 'title', 'label', 'short_description', 'long_description',
            'address', 'city', 'country', 'notes', 'storage_location', 'header', 'footer',
            'terms_and_conditions', 'supplier_name', 'reason'
        )
    )
);

-- ============================================
-- INDEXES FOR PERFORMANCE
-- ============================================

-- Supported Languages Indexes
CREATE INDEX IF NOT EXISTS idx_supported_languages_active ON supported_languages(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_supported_languages_default ON supported_languages(is_default) WHERE is_default = true;

-- Translation Metadata Indexes
CREATE INDEX IF NOT EXISTS idx_translation_metadata_entity ON translation_metadata(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_translation_metadata_source_lang ON translation_metadata(source_language);
CREATE INDEX IF NOT EXISTS idx_translation_metadata_entity_type ON translation_metadata(entity_type);

-- Translations Indexes
CREATE INDEX IF NOT EXISTS idx_translations_metadata ON translations(metadata_id);
CREATE INDEX IF NOT EXISTS idx_translations_language ON translations(language_code);
CREATE INDEX IF NOT EXISTS idx_translations_metadata_language ON translations(metadata_id, language_code);
CREATE INDEX IF NOT EXISTS idx_translations_field ON translations(field_name);
CREATE INDEX IF NOT EXISTS idx_translations_ai_generated ON translations(is_ai_generated);

-- Composite index for common query pattern: get all translations for an entity in a specific language
CREATE INDEX IF NOT EXISTS idx_translations_metadata_lang_field ON translations(metadata_id, language_code, field_name);

-- ============================================
-- SEED INITIAL LANGUAGES
-- ============================================

-- Insert supported languages
INSERT INTO supported_languages (code, name, native_name, is_active, is_default, rtl) VALUES
    ('en', 'English', 'English', true, true, false),
    ('ar', 'Arabic', 'العربية', true, false, true),
    ('ku', 'Kurdish', 'کوردی', true, false, true),
    ('fr', 'French', 'Français', true, false, false)
ON CONFLICT (code) DO UPDATE SET
    name = EXCLUDED.name,
    native_name = EXCLUDED.native_name,
    is_active = EXCLUDED.is_active,
    rtl = EXCLUDED.rtl,
    updated_at = NOW();

-- Ensure only one default language (in case of conflicts)
-- Set all others to false if a new default is set
CREATE OR REPLACE FUNCTION ensure_single_default_language()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.is_default = true THEN
        UPDATE supported_languages 
        SET is_default = false, updated_at = NOW()
        WHERE code != NEW.code AND is_default = true;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_ensure_single_default_language
    BEFORE INSERT OR UPDATE ON supported_languages
    FOR EACH ROW
    WHEN (NEW.is_default = true)
    EXECUTE FUNCTION ensure_single_default_language();

-- ============================================
-- HELPER FUNCTIONS (Optional but useful)
-- ============================================

-- Function to get translation for an entity in a specific language with fallback
CREATE OR REPLACE FUNCTION get_translation(
    p_entity_type VARCHAR(50),
    p_entity_id UUID,
    p_language_code VARCHAR(10),
    p_field_name VARCHAR(50),
    p_fallback_language VARCHAR(10) DEFAULT 'en'
)
RETURNS TEXT AS $$
DECLARE
    v_translation TEXT;
    v_metadata_id UUID;
BEGIN
    -- Get metadata ID
    SELECT id INTO v_metadata_id
    FROM translation_metadata
    WHERE entity_type = p_entity_type AND entity_id = p_entity_id;
    
    IF v_metadata_id IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Try to get translation in requested language
    SELECT translated_text INTO v_translation
    FROM translations
    WHERE metadata_id = v_metadata_id 
      AND language_code = p_language_code 
      AND field_name = p_field_name;
    
    -- If not found, try fallback language
    IF v_translation IS NULL AND p_fallback_language != p_language_code THEN
        SELECT translated_text INTO v_translation
        FROM translations
        WHERE metadata_id = v_metadata_id 
          AND language_code = p_fallback_language 
          AND field_name = p_field_name;
    END IF;
    
    RETURN v_translation;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================

COMMENT ON TABLE supported_languages IS 'Registry of all languages supported by the system. Languages can be activated/deactivated dynamically.';
COMMENT ON TABLE translation_metadata IS 'Metadata linking entities (ingredients, categories, etc.) to their translation records. Stores source language of original input.';
COMMENT ON TABLE translations IS 'Actual translated content. Stores translations for each field (name, description) in each supported language.';

COMMENT ON COLUMN supported_languages.code IS 'ISO 639-1 language code (e.g., en, ar, ku, fr)';
COMMENT ON COLUMN supported_languages.is_default IS 'Only one language should be marked as default (enforced by trigger)';
COMMENT ON COLUMN translation_metadata.source_language IS 'Original language in which the entity was created/input';
COMMENT ON COLUMN translations.is_ai_generated IS 'Indicates if translation was generated by AI (true) or manually edited by user (false)';
COMMENT ON COLUMN translations.last_updated_by IS 'User ID who last manually edited this translation. NULL for AI-generated translations.';

-- ============================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================

-- Supported Languages: Global table, accessible to all tenants
-- No RLS needed as this is system-wide configuration
-- But we'll enable it for consistency and allow read access
ALTER TABLE supported_languages ENABLE ROW LEVEL SECURITY;

CREATE POLICY supported_languages_read_policy ON supported_languages
    FOR SELECT
    USING (is_active = true);

-- Translation Metadata: Tenant-aware through entity relationships
-- Users can only access translations for entities in their tenant
ALTER TABLE translation_metadata ENABLE ROW LEVEL SECURITY;

-- Helper function to check tenant access for translation metadata
-- This function safely handles cases where tables might not exist yet using dynamic SQL
CREATE OR REPLACE FUNCTION check_translation_metadata_access(
    p_entity_type VARCHAR(50),
    p_entity_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
    v_result BOOLEAN := false;
    v_current_tenant UUID;
    v_table_name TEXT;
    v_query TEXT;
BEGIN
    -- Get current tenant
    v_current_tenant := get_current_tenant_id();
    
    -- Check if super admin
    BEGIN
        IF current_setting('app.is_super_admin', true)::BOOLEAN = true THEN
            RETURN true;
        END IF;
    EXCEPTION WHEN OTHERS THEN
        -- Setting doesn't exist, continue
    END;
    
    -- Map entity types to table names and build appropriate query
    CASE p_entity_type
        WHEN 'ingredient' THEN
            v_table_name := 'ingredients';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'category' THEN
            v_table_name := 'categories';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'food_item' THEN
            v_table_name := 'food_items';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'addon' THEN
            v_table_name := 'add_ons';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I ao JOIN %I aog ON ao.add_on_group_id = aog.id WHERE ao.id = $1 AND aog.tenant_id = $2)', v_table_name, 'add_on_groups');
        WHEN 'addon_group' THEN
            v_table_name := 'add_on_groups';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'variation' THEN
            v_table_name := 'variations';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I v JOIN %I vg ON v.variation_group_id = vg.id WHERE v.id = $1 AND vg.tenant_id = $2)', v_table_name, 'variation_groups');
        WHEN 'variation_group' THEN
            v_table_name := 'variation_groups';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'buffet' THEN
            v_table_name := 'buffets';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'combo_meal' THEN
            v_table_name := 'combo_meals';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'menu' THEN
            v_table_name := 'menus';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'branch' THEN
            v_table_name := 'branches';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'customer' THEN
            v_table_name := 'customers';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'employee' THEN
            -- Use 'users' table instead of 'employees'
            v_table_name := 'users';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'stock_operation' THEN
            v_table_name := 'stock_operations';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'invoice' THEN
            v_table_name := 'invoices';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'tax' THEN
            v_table_name := 'taxes';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1 AND tenant_id = $2)', v_table_name);
        WHEN 'restaurant' THEN
            -- Use 'tenants' table instead of 'restaurants' - no tenant_id check
            v_table_name := 'tenants';
            v_query := format('SELECT EXISTS (SELECT 1 FROM %I WHERE id = $1)', v_table_name);
        ELSE
            RETURN false;
    END CASE;
    
    -- Execute query dynamically with exception handling
    BEGIN
        IF p_entity_type = 'restaurant' THEN
            EXECUTE v_query INTO v_result USING p_entity_id;
        ELSE
            EXECUTE v_query INTO v_result USING p_entity_id, v_current_tenant;
        END IF;
    EXCEPTION 
        WHEN undefined_table THEN
            -- Table doesn't exist yet, deny access by default
            v_result := false;
        WHEN OTHERS THEN
            -- Other errors, deny access for safety
            v_result := false;
    END;
    
    RETURN v_result;
END;
$$ LANGUAGE plpgsql;

CREATE POLICY translation_metadata_tenant_isolation ON translation_metadata
    FOR ALL
    USING (
        check_translation_metadata_access(translation_metadata.entity_type, translation_metadata.entity_id)
    );

-- Translations: Tenant-aware through translation_metadata
-- The RLS on translation_metadata will cascade to translations
ALTER TABLE translations ENABLE ROW LEVEL SECURITY;

CREATE POLICY translations_tenant_isolation ON translations
    FOR ALL
    USING (
        -- Check if the metadata exists and is accessible (RLS on translation_metadata will apply)
        EXISTS (
            SELECT 1 FROM translation_metadata tm
            WHERE tm.id = translations.metadata_id
        )
        OR current_setting('app.is_super_admin', true)::BOOLEAN = true
    );

-- ============================================
-- TRIGGERS FOR UPDATED_AT
-- ============================================

-- Note: update_updated_at_column() function should already exist from 001_initial_schema.sql
-- If it doesn't exist, it will be created below as a safety measure

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at triggers to translation tables
CREATE TRIGGER update_supported_languages_updated_at 
    BEFORE UPDATE ON supported_languages
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_translation_metadata_updated_at 
    BEFORE UPDATE ON translation_metadata
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_translations_updated_at 
    BEFORE UPDATE ON translations
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

